require("dotenv").config({ path: "./.env" });

const express = require("express");
const bodyParser = require("body-parser");
const cors = require("cors");
const fetch = require("node-fetch");
const SpotifyWebApi = require("spotify-web-api-node");
const fs = require("fs");

const app = express();
app.use(bodyParser.json());
app.use(cors());

// YouTube API Keys 설정
// API 키 배열로 변환
const YOUTUBE_API_KEYS = process.env.YOUTUBE_API_KEY.split(",").map((key) => key.trim());
let currentApiKeyIndex = 0;

// 현재 API 키 가져오기
const getCurrentYouTubeApiKey = () => YOUTUBE_API_KEYS[currentApiKeyIndex];

// API 키 교체 로직
const rotateYouTubeApiKey = () => {
  currentApiKeyIndex = (currentApiKeyIndex + 1) % YOUTUBE_API_KEYS.length;
  console.log(
    `YouTube API Key rotated: ${getCurrentYouTubeApiKey()} (Index: ${currentApiKeyIndex})`
  );
};

// Spotify Access Token 관리 변수
let spotifyAccessToken = null;
let tokenExpiryTime = null;

// Spotify API 설정
const spotifyApi = new SpotifyWebApi({
  clientId: process.env.SPOTIFY_CLIENT_ID,
  clientSecret: process.env.SPOTIFY_CLIENT_SECRET,
});

// Spotify Access Token 갱신 함수
const refreshSpotifyAccessToken = async () => {
  try {
    const data = await spotifyApi.clientCredentialsGrant();
    spotifyAccessToken = data.body["access_token"];
    tokenExpiryTime = Date.now() + data.body["expires_in"] * 1000; // 만료 시간 설정
    spotifyApi.setAccessToken(spotifyAccessToken);
    console.log("Spotify Access Token 갱신 완료:", spotifyAccessToken);
  } catch (error) {
    console.error("Spotify Access Token 갱신 중 오류:", error.message);
    throw new Error("Spotify Access Token 갱신 실패");
  }
};

// Access Token 유효성 확인 함수
const ensureSpotifyAccessToken = async () => {
  if (!spotifyAccessToken || Date.now() >= tokenExpiryTime) {
    console.log("Spotify Access Token 만료. 갱신 중...");
    await refreshSpotifyAccessToken();
  }
};

// YouTube API 변환 로직
let retryCount = 0; // 재시도 횟수
const MAX_RETRY = 3; // 최대 재시도 제한

const convertToYouTube = async (track) => {
  try {
    console.log("Track for YouTube Search (Full Object):", track);

    if (!track || !track.name || !track.artist) {
      throw new Error("Track 데이터가 올바르지 않습니다.");
    }

    // 제목에서 "(with ~)" 및 "(feat. ~)" 제거
    const cleanedName = track.name
      .replace(/\(with [^\)]+\)/gi, "")
      .replace(/\(feat\. [^\)]+\)/gi, "")
      .trim();

    const searchQuery = `"${cleanedName}" "${track.artist}"`;
    const youtubeSearchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&order=relevance&key=${getCurrentYouTubeApiKey()}&q=${encodeURIComponent(
      searchQuery
    )}`;
    console.log("YouTube Search URL:", youtubeSearchUrl);

    const response = await fetch(youtubeSearchUrl);
    const data = await response.json();

    if (data.error && data.error.errors[0].reason === "quotaExceeded") {
      console.log("YouTube API Quota Exceeded. Rotating API Key...");
      rotateYouTubeApiKey();

      // 재시도 로직
      retryCount++;
      if (retryCount < MAX_RETRY) {
        return await convertToYouTube(track); // 순환 호출
      } else {
        throw new Error("YouTube API Key 순환 시도 초과");
      }
    }

    if (data.items && data.items.length > 0) {
      const autoGeneratedVideo = data.items.find((item) => {
        const videoDescription = item.snippet.description.toLowerCase();
        const videoTitle = item.snippet.title.toLowerCase();
        const mainArtist = track.artist.split(",")[0].toLowerCase();

        const isAutoGenerated =
          (videoDescription.includes("provided to youtube by") ||
            videoDescription.includes("auto-generated by youtube")) &&
          videoTitle.includes(mainArtist);

        return isAutoGenerated;
      });

      if (autoGeneratedVideo) {
        console.log("Selected Auto-Generated Video:", autoGeneratedVideo.snippet.title);
        return `https://www.youtube.com/watch?v=${autoGeneratedVideo.id.videoId}`;
      } else {
        const fallbackVideo = data.items[0];
        console.log("Fallback YouTube Video:", fallbackVideo.snippet.title);
        return `https://www.youtube.com/watch?v=${fallbackVideo.id.videoId}`;
      }
    } else {
      throw new Error("YouTube에서 변환된 결과가 없습니다.");
    }
  } catch (error) {
    console.error("YouTube 변환 중 오류:", error);
    return null;
  }
};

// Spotify 플레이리스트 가져오기
app.get("/spotify/playlist", async (req, res) => {
  const playlistId = req.query.id;

  if (!playlistId) {
    return res.status(400).json({ error: "플레이리스트 ID를 제공해주세요." });
  }

  try {
    await ensureSpotifyAccessToken(); // Spotify Access Token 갱신 확인
    const data = await spotifyApi.getPlaylist(playlistId);
    res.json({
      name: data.body.name,
      description: data.body.description,
      tracks: data.body.tracks.items.map((item) => ({
        name: item.track.name,
        artist: item.track.artists.map((artist) => artist.name).join(", "),
        album: item.track.album.name,
      })),
    });
  } catch (error) {
    console.error("Spotify API 호출 중 오류 발생:", error.message);
    res.status(500).json({ error: "플레이리스트를 가져오는 중 오류가 발생했습니다." });
  }
});

// POST /convert API
app.post("/convert", async (req, res) => {
  const { sourcePlatform, destinationPlatform, playlistData } = req.body;

  try {
    if (sourcePlatform === 'spotify' && destinationPlatform === 'youtube') {
      // Step 1: 각 트랙을 YouTube 링크로 변환
      const youtubeLinks = await Promise.all(
        playlistData.tracks.map((track) => convertToYouTube(track))
      );

      // Step 2: YouTube Video IDs 추출
      const videoIds = youtubeLinks.map((link) => {
        const url = new URL(link);
        return url.searchParams.get('v');
      });

      // Step 3: YouTube 플레이리스트 생성
      const playlistUrl = await createYouTubePlaylist(
        playlistData.name,
        videoIds
      );

      res.json({ playlistUrl });
    } else {
      res.status(400).json({ error: "지원되지 않는 플랫폼 조합입니다." });
    }
  } catch (error) {
    console.error("플레이리스트 변환 중 오류:", error.message);
    res.status(500).json({ error: "플레이리스트 변환 중 오류가 발생했습니다." });
  }
});

// OAuth 설정과 인증 경로를 추가
const { google } = require('googleapis');
const OAuth2 = google.auth.OAuth2;
const oauth2Client = new OAuth2(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  process.env.GOOGLE_REDIRECT_URI // 환경 변수로 설정된 ngrok URL 사용
);

// 서버 시작 시 Refresh Token 로드
if (fs.existsSync("refresh_token.json")) {
  const refreshToken = JSON.parse(fs.readFileSync("refresh_token.json", "utf8"));
  oauth2Client.setCredentials({ refresh_token: refreshToken });
  console.log("Saved Refresh Token 로드 완료");
} else {
  console.log("Refresh Token 파일이 없습니다. OAuth 인증이 필요합니다.");
}

// 인증 URL 생성
app.get('/auth', (req, res) => {
  const scopes = ['https://www.googleapis.com/auth/youtube'];
  const url = oauth2Client.generateAuthUrl({
    access_type: 'offline', // Refresh Token 요청
    prompt: 'consent', // 강제로 동의 화면 표시
    scope: scopes,
  });
  res.redirect(url);
});

// 서버 시작 시 Refresh Token 로드
if (fs.existsSync("refresh_token.json")) {
  const refreshToken = JSON.parse(fs.readFileSync("refresh_token.json", "utf8"));
  oauth2Client.setCredentials({ refresh_token: refreshToken });
  console.log("Saved Refresh Token 로드 완료");
} else {
  console.log("Refresh Token 파일이 없습니다. /auth 경로로 인증을 다시 수행하세요.");
}

// OAuth2 Callback 처리
app.get('/oauth2callback', async (req, res) => {
  const code = req.query.code;
  try {
    const { tokens } = await oauth2Client.getToken(code);
    oauth2Client.setCredentials(tokens);

    console.log("Tokens received:", tokens); // 디버깅용 로그 추가

    if (tokens.refresh_token) {
      fs.writeFileSync("refresh_token.json", JSON.stringify(tokens.refresh_token));
      console.log("Refresh Token 저장 완료");
    } else {
      console.warn("Refresh Token이 반환되지 않았습니다.");
    }

    res.send("Authentication successful! You can close this window.");
  } catch (error) {
    console.error("OAuth 토큰 처리 중 오류:", error.message);
    res.status(500).send("Authentication failed.");
  }
});

const ensureYouTubeAccessToken = async () => {
  const tokens = oauth2Client.credentials;

  // Access Token이 설정되지 않은 경우 예외 처리
  if (!tokens || !tokens.access_token) {
    throw new Error("YouTube Access Token이 설정되지 않았습니다.");
  }

  // Access Token이 만료된 경우 갱신
  if (tokens.expiry_date && tokens.expiry_date <= Date.now()) {
    console.log("YouTube Access Token 만료. 갱신 중...");
    try {
      const { credentials: refreshedTokens } = await oauth2Client.refreshAccessToken();
      oauth2Client.setCredentials(refreshedTokens);
      console.log("YouTube Access Token 갱신 완료:", refreshedTokens.access_token);
    } catch (error) {
      console.error("YouTube Access Token 갱신 중 오류:", error.message);
      throw new Error("Access Token 갱신 실패");
    }
  }
};

// 플레이리스트 생성 함수
const createYouTubePlaylist = async (playlistName, videoIds) => {
  await ensureYouTubeAccessToken(); // Access Token 유효성 확인 및 갱신

  const youtube = google.youtube({
    version: "v3",
    auth: oauth2Client, // 인증된 OAuth2 클라이언트 사용
  });

  try {
    // 1. 새로운 플레이리스트 생성
    const playlistResponse = await youtube.playlists.insert({
      part: "snippet,status",
      requestBody: {
        snippet: { title: playlistName, description: "Generated by Playlist Converter" },
        status: { privacyStatus: "private" },
      },
    });

    const playlistId = playlistResponse.data.id;
    console.log("Created playlist with ID:", playlistId);

    // 2. 플레이리스트에 동영상 추가
    for (const videoId of videoIds) {
      await youtube.playlistItems.insert({
        part: "snippet",
        requestBody: {
          snippet: {
            playlistId: playlistId,
            resourceId: { kind: "youtube#video", videoId: videoId },
          },
        },
      });
      console.log(`Added video ${videoId} to playlist`);
    }

    return `https://www.youtube.com/playlist?list=${playlistId}`;
  } catch (error) {
    console.error("YouTube 플레이리스트 생성 중 오류:", error.message);
    throw new Error("YouTube 플레이리스트 생성 실패");
  }
};


// 서버 실행
const PORT = 5001;
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});